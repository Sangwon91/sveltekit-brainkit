---
trigger: always_on
glob: "*"
description: "D3.js Visualization Rules for SvelteKit"
---

# D3.js Visualization Rules for SvelteKit

## Why D3 + Svelte is a Perfect Match

Svelte's **direct DOM manipulation philosophy** aligns naturally with D3's imperative API. Unlike React, there's no Virtual DOM reconciliation conflict. Svelte compiles away, leaving just your D3 code running directly on the DOM.

**Key Advantages:**
- **No VDOM Conflict:** Svelte doesn't diff the DOM, so D3's direct mutations work seamlessly.
- **Reactive Bindings:** Use `$effect` to trigger D3 updates when data changes.
- **Simpler Refs:** `bind:this` provides direct element access without wrapper overhead.
- **Lifecycle Clarity:** `$effect` with cleanup functions replaces complex hook patterns.

## Core Philosophy

-   **D3 Imperative Pattern (Recommended):** Use D3.js directly for all visualization logic. Avoid mixing Svelte's `{#each}` with D3 rendering—pick one approach for consistency.
-   **Svelte for Infrastructure:** Use Svelte for container management (`bind:this`), conditional UI (tooltips, loading states), and state management (`$state`, `$derived`).
-   **Performance-First:** Choose between SVG and Canvas based on data volume.
-   **SSR-Safe by Default:** In Svelte 5, `$effect` does NOT run during SSR. Simply guard with element refs (`if (!svgEl) return`). **No `onMount` or `browser` checks needed.**

## Code Management Strategy

Always use **D3 imperative pattern** for visualization code. Reasons:

| Aspect | D3 Imperative | Svelte Declarative |
|--------|---------------|-------------------|
| **Consistency** | ✅ One pattern for everything | ❌ Axes still need D3 |
| **Ecosystem** | ✅ All D3 examples work | ⚠️ Must translate |
| **Portability** | ✅ Works in React/Vue too | ❌ Svelte-only |
| **Complex Charts** | ✅ Brush, Zoom, Transitions | ⚠️ Limited support |

**Exception:** For very simple shapes without axes, Svelte declarative can be used. See [Rendering Strategies](d3/references/rendering_strategies.md).

## 1. Rendering Strategy

Choose the rendering backend based on simultaneous elements.

| Data Points | Strategy | Note |
|---|---|---|
| **< 1,000** | **SVG Only** | Simplest. CSS styling and native events work out of the box. |
| **1k - 10k** | **Hybrid** | SVG for axes/text, Canvas for data points. |
| **> 10,000** | **Canvas** | Full Canvas or Hybrid. Interaction requires hit detection. |

See [Rendering Strategies](d3/references/rendering_strategies.md) for SVG implementations.
See [Canvas Patterns](d3/references/canvas_patterns.md) for Canvas implementations.

## 2. Layer Architecture (Block Box)

Prevent DOM conflicts by giving D3 its own sandbox via `bind:this`.

-   **Structure**: Container `div` (relative) -> `canvas` (absolute) -> `svg` (absolute, pointer-events-none).
-   **Constraint**: Svelte manages the container and bindings. D3 manages everything *inside* the bound elements.
-   **Cleanup**: Always clear the specific layer (`selectAll('*').remove()` or `clearRect`) before re-drawing.

See [Layer Architecture](d3/references/layer_architecture.md) for the boilerplate.

## 3. Interaction Strategy

-   **Small Data (<2k)**: Use **SVG Overlay** (Voronoi or invisible circles) for fuzzy finding and best UX.
-   **Large Data (>2k)**: Use **Canvas Hit Detection** (Euclidean distance or Color-picking) for performance.

See [Interaction Patterns](d3/references/interaction_patterns.md).

## 4. SvelteKit Integration Workflow

1.  **Use `$effect` Only**: `$effect` does NOT run during SSR in Svelte 5. Guard with element refs only.
2.  **No `onMount` Needed**: `$effect` with element ref guard is sufficient for all D3 code.
3.  **Responsive Container**: Use `ResizeObserver` in `$effect` to drive D3 dimensions.
4.  **Dependencies**: Use `$derived` for expensive data transforms. Let `$effect` react to state changes.
5.  **Server Boundary**: Fetch data in `+page.server.ts` / `+layout.server.ts` and pass via `data` prop.

See [SvelteKit Integration](d3/references/sveltekit_integration.md) and [Optimization](d3/references/optimization.md).

## Example: Hybrid Chart Template (Svelte 5 Runes)

```svelte
<script lang="ts">
  import * as d3 from 'd3';

  interface Props {
    data: { x: number; y: number }[];
  }

  let { data }: Props = $props();

  let containerEl: HTMLDivElement;
  let svgEl: SVGSVGElement;
  let canvasEl: HTMLCanvasElement;

  // ✅ Memoize scales with $derived
  let xScale = $derived(
    d3.scaleLinear()
      .domain(d3.extent(data, d => d.x) as [number, number])
      .range([40, 780])
  );

  let yScale = $derived(
    d3.scaleLinear()
      .domain(d3.extent(data, d => d.y) as [number, number])
      .range([370, 20])
  );

  $effect(() => {
    // ✅ Element ref guard - NO onMount or browser check needed
    if (!containerEl || !svgEl || !canvasEl) return;

    const { width, height } = containerEl.getBoundingClientRect();

    // 1. Canvas: Data Points
    const ctx = canvasEl.getContext('2d');
    if (!ctx) return;
    canvasEl.width = width;
    canvasEl.height = height;
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = 'steelblue';
    for (const d of data) {
      ctx.beginPath();
      ctx.arc(xScale(d.x), yScale(d.y), 3, 0, 2 * Math.PI);
      ctx.fill();
    }

    // 2. SVG: Axes (D3 imperative - required for axes)
    const svg = d3.select(svgEl);
    svg.attr('width', width).attr('height', height);
    svg.selectAll('*').remove();

    svg.append('g')
      .attr('transform', `translate(0, ${height - 30})`)
      .call(d3.axisBottom(xScale));
    
    svg.append('g')
      .attr('transform', 'translate(40, 0)')
      .call(d3.axisLeft(yScale));

    // ✅ Cleanup function
    return () => {
      svg.selectAll('*').remove();
      ctx.clearRect(0, 0, width, height);
    };
  });
</script>

<!-- ✅ Svelte manages container, D3 manages content -->
<div bind:this={containerEl} class="relative w-full h-[400px]">
  <canvas bind:this={canvasEl} class="absolute inset-0" />
  <svg bind:this={svgEl} class="absolute inset-0 pointer-events-none" />
</div>
```

## Quick Reference

| Concept | React/Next.js | Svelte 5 / SvelteKit |
|---------|---------------|----------------------|
| Element Ref | `useRef` | `bind:this` |
| Side Effects | `useLayoutEffect` | `$effect` |
| Memoization | `useMemo` | `$derived` |
| Client Only | `'use client'` | `$effect` with ref guard |
| Data Fetching | Server Component props | `+page.server.ts` → `data` prop |

## Anti-Patterns

| ❌ Anti-Pattern | ✅ Correct Approach |
|-----------------|---------------------|
| Using `onMount` for D3 | `$effect` with element ref guard |
| Mixing `{#each}` with D3 for same elements | Pick one: D3 imperative OR Svelte declarative |
| `d3.select()` for simple attributes | Use Svelte: `<svg {width} {height}>` |
| Missing cleanup in `$effect` | Always return cleanup function |
| Heavy computation inside `$effect` | Extract to `$derived` |
